# Web3 —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏: Python & JavaScript

# Web3.py (Python)

````
# ========== –£–°–¢–ê–ù–û–í–ö–ê ==========
"""
pip install web3
pip install python-dotenv
pip install eth-account
"""

from web3 import Web3
from web3.middleware import geth_poa_middleware
from eth_account import Account
import json
import os
from dotenv import load_dotenv

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# ========== –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö –ë–õ–û–ö–ß–ï–ô–ù–£ ==========

class BlockchainConnector:
    def __init__(self, provider_url):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–ª–æ–∫—á–µ–π–Ω—É
        
        provider_url –ø—Ä–∏–º–µ—Ä—ã:
        - HTTP: "http://127.0.0.1:8545" (–ª–æ–∫–∞–ª—å–Ω—ã–π)
        - Infura: "https://mainnet.infura.io/v3/YOUR-PROJECT-ID"
        - Alchemy: "https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY"
        - WebSocket: "wss://mainnet.infura.io/ws/v3/YOUR-PROJECT-ID"
        """
        self.w3 = Web3(Web3.HTTPProvider(provider_url))
        
        # –î–ª—è PoA —Å–µ—Ç–µ–π (Polygon, BSC –∏ —Ç.–¥.)
        self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        if self.w3.is_connected():
            print(f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ –±–ª–æ–∫—á–µ–π–Ω—É")
            print(f"Chain ID: {self.w3.eth.chain_id}")
        else:
            raise Exception("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –±–ª–æ–∫—á–µ–π–Ω—É")
    
    def get_connection(self):
        return self.w3

# ========== –ë–ê–ó–û–í–´–ï –û–ü–ï–†–ê–¶–ò–ò ==========

def basic_operations():
    # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
    w3 = Web3(Web3.HTTPProvider('https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY'))
    
    # 1. –ü–†–û–í–ï–†–ö–ê –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–Ø
    print(f"Connected: {w3.is_connected()}")
    
    # 2. –ü–û–õ–£–ß–ò–¢–¨ –ü–û–°–õ–ï–î–ù–ò–ô –ë–õ–û–ö
    latest_block = w3.eth.block_number
    print(f"Latest block: {latest_block}")
    
    # 3. –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ë–õ–û–ö–ï
    block = w3.eth.get_block('latest')
    print(f"Block timestamp: {block['timestamp']}")
    print(f"Block transactions: {len(block['transactions'])}")
    
    # 4. –ü–û–õ–£–ß–ò–¢–¨ –ë–ê–õ–ê–ù–° –ê–î–†–ï–°–ê
    address = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'  # Vitalik's address
    balance_wei = w3.eth.get_balance(address)
    balance_eth = w3.from_wei(balance_wei, 'ether')
    print(f"Balance: {balance_eth} ETH")
    
    # 5. –¶–ï–ù–ê –ì–ê–ó–ê
    gas_price = w3.eth.gas_price
    gas_price_gwei = w3.from_wei(gas_price, 'gwei')
    print(f"Gas price: {gas_price_gwei} Gwei")
    
    # 6. –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –¢–†–ê–ù–ó–ê–ö–¶–ò–ò
    tx_hash = '0x...'  # hash —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    # tx = w3.eth.get_transaction(tx_hash)
    # print(f"From: {tx['from']}")
    # print(f"To: {tx['to']}")
    # print(f"Value: {w3.from_wei(tx['value'], 'ether')} ETH")
    
    # 7. RECEIPT –¢–†–ê–ù–ó–ê–ö–¶–ò–ò
    # receipt = w3.eth.get_transaction_receipt(tx_hash)
    # print(f"Status: {'Success' if receipt['status'] == 1 else 'Failed'}")
    # print(f"Gas used: {receipt['gasUsed']}")

# ========== –†–ê–ë–û–¢–ê –° –ê–ö–ö–ê–£–ù–¢–ê–ú–ò ==========

class WalletManager:
    def __init__(self, w3):
        self.w3 = w3
    
    def create_account(self):
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∞–∫–∫–∞—É–Ω—Ç"""
        account = Account.create()
        return {
            'address': account.address,
            'private_key': account.key.hex()
        }
    
    def import_account(self, private_key):
        """–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç –ø–æ –ø—Ä–∏–≤–∞—Ç–Ω–æ–º—É –∫–ª—é—á—É"""
        account = Account.from_key(private_key)
        return account
    
    def get_balance(self, address):
        """–ü–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å –≤ ETH"""
        balance_wei = self.w3.eth.get_balance(address)
        return self.w3.from_wei(balance_wei, 'ether')
    
    def get_nonce(self, address):
        """–ü–æ–ª—É—á–∏—Ç—å nonce –¥–ª—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏"""
        return self.w3.eth.get_transaction_count(address)

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
def wallet_example():
    w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))
    wallet = WalletManager(w3)
    
    # –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∫–æ—à–µ–ª–µ–∫
    new_account = wallet.create_account()
    print(f"New Address: {new_account['address']}")
    print(f"Private Key: {new_account['private_key']}")
    
    # –í–ê–ñ–ù–û: –•—Ä–∞–Ω–∏—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –≤ .env —Ñ–∞–π–ª–µ!
    # –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –∫–æ–º–º–∏—Ç—å—Ç–µ –µ–≥–æ –≤ git!

# ========== –û–¢–ü–†–ê–í–ö–ê –¢–†–ê–ù–ó–ê–ö–¶–ò–ô ==========

class TransactionManager:
    def __init__(self, w3, private_key):
        self.w3 = w3
        self.account = Account.from_key(private_key)
        self.address = self.account.address
    
    def send_eth(self, to_address, amount_eth):
        """
        –û—Ç–ø—Ä–∞–≤–∏—Ç—å ETH
        
        Args:
            to_address: –∞–¥—Ä–µ—Å –ø–æ–ª—É—á–∞—Ç–µ–ª—è
            amount_eth: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ ETH
        """
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º ETH –≤ Wei
        amount_wei = self.w3.to_wei(amount_eth, 'ether')
        
        # –ü–æ–ª—É—á–∞–µ–º nonce
        nonce = self.w3.eth.get_transaction_count(self.address)
        
        # –°–æ–∑–¥–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
        transaction = {
            'nonce': nonce,
            'to': to_address,
            'value': amount_wei,
            'gas': 21000,  # —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π gas –¥–ª—è ETH –ø–µ—Ä–µ–≤–æ–¥–∞
            'gasPrice': self.w3.eth.gas_price,
            'chainId': self.w3.eth.chain_id
        }
        
        # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
        signed_txn = self.w3.eth.account.sign_transaction(
            transaction, 
            self.account.key
        )
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
        tx_hash = self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)
        
        print(f"Transaction sent! Hash: {tx_hash.hex()}")
        
        # –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
        tx_receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
        
        if tx_receipt['status'] == 1:
            print("‚úÖ Transaction successful!")
        else:
            print("‚ùå Transaction failed!")
        
        return tx_hash.hex()
    
    def send_eip1559_transaction(self, to_address, amount_eth):
        """
        –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é —Å EIP-1559 (London fork)
        –ë–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≥–∞–∑–∞
        """
        amount_wei = self.w3.to_wei(amount_eth, 'ether')
        nonce = self.w3.eth.get_transaction_count(self.address)
        
        # –ü–æ–ª—É—á–∞–µ–º –±–∞–∑–æ–≤—É—é –∫–æ–º–∏—Å—Å–∏—é –∏ priority fee
        latest_block = self.w3.eth.get_block('latest')
        base_fee = latest_block['baseFeePerGas']
        max_priority_fee = self.w3.to_wei(2, 'gwei')  # tip –¥–ª—è –º–∞–π–Ω–µ—Ä–∞
        max_fee = base_fee * 2 + max_priority_fee  # –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –ø–ª–∞—Ç–∏—Ç—å
        
        transaction = {
            'nonce': nonce,
            'to': to_address,
            'value': amount_wei,
            'gas': 21000,
            'maxFeePerGas': max_fee,
            'maxPriorityFeePerGas': max_priority_fee,
            'chainId': self.w3.eth.chain_id,
            'type': 2  # EIP-1559
        }
        
        signed_txn = self.w3.eth.account.sign_transaction(
            transaction, 
            self.account.key
        )
        
        tx_hash = self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)
        print(f"EIP-1559 Transaction sent! Hash: {tx_hash.hex()}")
        
        return tx_hash.hex()

# ========== –†–ê–ë–û–¢–ê –°–û –°–ú–ê–†–¢-–ö–û–ù–¢–†–ê–ö–¢–ê–ú–ò ==========

class ContractManager:
    def __init__(self, w3, contract_address, abi):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
        
        Args:
            w3: Web3 instance
            contract_address: –∞–¥—Ä–µ—Å –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
            abi: ABI –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ (JSON)
        """
        self.w3 = w3
        self.contract = w3.eth.contract(
            address=Web3.to_checksum_address(contract_address),
            abi=abi
        )
        self.address = contract_address
    
    def call_view_function(self, function_name, *args):
        """
        –í—ã–∑–≤–∞—Ç—å view/pure —Ñ—É–Ω–∫—Ü–∏—é (–Ω–µ —Ç—Ä–µ–±—É–µ—Ç –≥–∞–∑–∞)
        
        Example:
            balance = contract.call_view_function('balanceOf', user_address)
        """
        function = getattr(self.contract.functions, function_name)
        return function(*args).call()
    
    def send_transaction(self, private_key, function_name, *args, value=0):
        """
        –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é (–∏–∑–º–µ–Ω—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ)
        
        Example:
            tx_hash = contract.send_transaction(
                private_key,
                'transfer',
                recipient,
                amount
            )
        """
        account = Account.from_key(private_key)
        
        # –ü–æ–ª—É—á–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é
        function = getattr(self.contract.functions, function_name)
        
        # –°—Ç—Ä–æ–∏–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
        transaction = function(*args).build_transaction({
            'from': account.address,
            'nonce': self.w3.eth.get_transaction_count(account.address),
            'gas': 200000,  # –º–æ–∂–Ω–æ –æ—Ü–µ–Ω–∏—Ç—å —á–µ—Ä–µ–∑ estimate_gas
            'gasPrice': self.w3.eth.gas_price,
            'value': value,
            'chainId': self.w3.eth.chain_id
        })
        
        # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º
        signed_txn = self.w3.eth.account.sign_transaction(
            transaction,
            private_key
        )
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º
        tx_hash = self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)
        
        # –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
        
        return {
            'tx_hash': tx_hash.hex(),
            'status': receipt['status'],
            'gas_used': receipt['gasUsed']
        }
    
    def estimate_gas(self, function_name, *args, from_address=None):
        """–û—Ü–µ–Ω–∏—Ç—å –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–π –≥–∞–∑"""
        function = getattr(self.contract.functions, function_name)
        return function(*args).estimate_gas({'from': from_address})

# ========== –ü–†–ò–ú–ï–†: –†–ê–ë–û–¢–ê –° ERC-20 –¢–û–ö–ï–ù–û–ú ==========

def erc20_example():
    # ABI –¥–ª—è ERC-20 (—É–ø—Ä–æ—â–µ–Ω–Ω—ã–π)
    ERC20_ABI = json.loads('''
    [
        {
            "constant": true,
            "inputs": [],
            "name": "name",
            "outputs": [{"name": "", "type": "string"}],
            "type": "function"
        },
        {
            "constant": true,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"name": "", "type": "string"}],
            "type": "function"
        },
        {
            "constant": true,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"name": "", "type": "uint256"}],
            "type": "function"
        },
        {
            "constant": true,
            "inputs": [{"name": "account", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"name": "", "type": "uint256"}],
            "type": "function"
        },
        {
            "constant": false,
            "inputs": [
                {"name": "recipient", "type": "address"},
                {"name": "amount", "type": "uint256"}
            ],
            "name": "transfer",
            "outputs": [{"name": "", "type": "bool"}],
            "type": "function"
        },
        {
            "constant": false,
            "inputs": [
                {"name": "spender", "type": "address"},
                {"name": "amount", "type": "uint256"}
            ],
            "name": "approve",
            "outputs": [{"name": "", "type": "bool"}],
            "type": "function"
        }
    ]
    ''')
    
    # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
    w3 = Web3(Web3.HTTPProvider('https://mainnet.infura.io/v3/YOUR-KEY'))
    
    # USDT –∫–æ–Ω—Ç—Ä–∞–∫—Ç –Ω–∞ Ethereum
    usdt_address = '0xdAC17F958D2ee523a2206206994597C13D831ec7'
    
    # –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç—Ä–∞–∫—Ç
    usdt = ContractManager(w3, usdt_address, ERC20_ABI)
    
    # –ß–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ (–Ω–µ —Ç—Ä–µ–±—É–µ—Ç –≥–∞–∑–∞)
    name = usdt.call_view_function('name')
    symbol = usdt.call_view_function('symbol')
    total_supply = usdt.call_view_function('totalSupply')
    
    print(f"Token: {name} ({symbol})")
    print(f"Total Supply: {total_supply / 10**6} USDT")  # USDT has 6 decimals
    
    # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å
    user_address = '0x...'
    balance = usdt.call_view_function('balanceOf', user_address)
    print(f"Balance: {balance / 10**6} USDT")
    
    # –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–æ–∫–µ–Ω—ã (—Ç—Ä–µ–±—É–µ—Ç –≥–∞–∑ –∏ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á)
    # private_key = os.getenv('PRIVATE_KEY')
    # recipient = '0x...'
    # amount = 100 * 10**6  # 100 USDT
    # 
    # result = usdt.send_transaction(
    #     private_key,
    #     'transfer',
    #     recipient,
    #     amount
    # )
    # print(f"Transaction: {result['tx_hash']}")

# ========== –°–õ–£–®–ê–¢–¨ –°–û–ë–´–¢–ò–Ø (EVENTS) ==========

class EventListener:
    def __init__(self, w3, contract_address, abi):
        self.w3 = w3
        self.contract = w3.eth.contract(
            address=Web3.to_checksum_address(contract_address),
            abi=abi
        )
    
    def get_past_events(self, event_name, from_block=0, to_block='latest'):
        """
        –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—à–ª—ã–µ —Å–æ–±—ã—Ç–∏—è
        
        Example:
            transfers = listener.get_past_events(
                'Transfer',
                from_block=15000000,
                to_block=15001000
            )
        """
        event = getattr(self.contract.events, event_name)
        return event.get_logs(fromBlock=from_block, toBlock=to_block)
    
    def listen_for_events(self, event_name, callback):
        """
        –°–ª—É—à–∞—Ç—å –Ω–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
        –¢—Ä–µ–±—É–µ—Ç WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
        """
        event = getattr(self.contract.events, event_name)
        event_filter = event.create_filter(fromBlock='latest')
        
        while True:
            for event in event_filter.get_new_entries():
                callback(event)

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
def event_example():
    w3 = Web3(Web3.HTTPProvider('https://mainnet.infura.io/v3/YOUR-KEY'))
    
    # ERC-20 –∫–æ–Ω—Ç—Ä–∞–∫—Ç
    contract_address = '0x...'
    abi = [...]  # ABI —Å —Å–æ–±—ã—Ç–∏–µ–º Transfer
    
    listener = EventListener(w3, contract_address, abi)
    
    # –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—à–ª—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä—ã
    transfers = listener.get_past_events('Transfer', from_block=18000000, to_block=18001000)
    
    for transfer in transfers:
        print(f"From: {transfer['args']['from']}")
        print(f"To: {transfer['args']['to']}")
        print(f"Amount: {transfer['args']['value']}")
        print(f"Block: {transfer['blockNumber']}")
        print("---")

# ========== –î–ï–ü–õ–û–ô –ö–û–ù–¢–†–ê–ö–¢–ê ==========

def deploy_contract(w3, private_key, bytecode, abi, constructor_args=None):
    """
    –ó–∞–¥–µ–ø–ª–æ–∏—Ç—å —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç
    
    Args:
        w3: Web3 instance
        private_key: –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –¥–µ–ø–ª–æ–µ—Ä–∞
        bytecode: —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π bytecode –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
        abi: ABI –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
        constructor_args: –∞—Ä–≥—É–º–µ–Ω—Ç—ã –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞
    """
    account = Account.from_key(private_key)
    
    # –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç—Ä–∞–∫—Ç
    Contract = w3.eth.contract(abi=abi, bytecode=bytecode)
    
    # –°—Ç—Ä–æ–∏–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–µ–ø–ª–æ—è
    if constructor_args:
        transaction = Contract.constructor(*constructor_args).build_transaction({
            'from': account.address,
            'nonce': w3.eth.get_transaction_count(account.address),
            'gas': 3000000,
            'gasPrice': w3.eth.gas_price,
            'chainId': w3.eth.chain_id
        })
    else:
        transaction = Contract.constructor().build_transaction({
            'from': account.address,
            'nonce': w3.eth.get_transaction_count(account.address),
            'gas': 3000000,
            'gasPrice': w3.eth.gas_price,
            'chainId': w3.eth.chain_id
        })
    
    # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º
    signed_txn = w3.eth.account.sign_transaction(transaction, private_key)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º
    tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
    print(f"Deploy transaction sent: {tx_hash.hex()}")
    
    # –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    
    contract_address = receipt['contractAddress']
    print(f"‚úÖ Contract deployed at: {contract_address}")
    
    return contract_address

# ========== –ü–û–õ–ù–´–ô –ü–†–ò–ú–ï–†: ERC-20 BOT ==========

class ERC20Bot:
    """–ë–æ—Ç –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å ERC-20 —Ç–æ–∫–µ–Ω–æ–º"""
    
    def __init__(self, provider_url, contract_address, abi, private_key=None):
        self.w3 = Web3(Web3.HTTPProvider(provider_url))
        self.contract = ContractManager(self.w3, contract_address, abi)
        self.private_key = private_key
        
        if private_key:
            self.account = Account.from_key(private_key)
            self.address = self.account.address
    
    def get_token_info(self):
        """–ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–∫–µ–Ω–µ"""
        return {
            'name': self.contract.call_view_function('name'),
            'symbol': self.contract.call_view_function('symbol'),
            'decimals': self.contract.call_view_function('decimals'),
            'total_supply': self.contract.call_view_function('totalSupply')
        }
    
    def get_balance(self, address=None):
        """–ü–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å"""
        if address is None:
            address = self.address
        
        balance = self.contract.call_view_function('balanceOf', address)
        decimals = self.contract.call_view_function('decimals')
        
        return balance / (10 ** decimals)
    
    def transfer(self, to_address, amount):
        """–ü–µ—Ä–µ–≤–µ—Å—Ç–∏ —Ç–æ–∫–µ–Ω—ã"""
        if not self.private_key:
            raise Exception("Private key required for transactions")
        
        decimals = self.contract.call_view_function('decimals')
        amount_wei = int(amount * (10 ** decimals))
        
        result = self.contract.send_transaction(
            self.private_key,
            'transfer',
            to_address,
            amount_wei
        )
        
        return result

if __name__ == "__main__":
    # –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    print("Web3.py Examples")
    print("=" * 50)
    
    # basic_operations()
    # wallet_example()
    # erc20_example()
````

## Web3.js & Ethers.js (JavaScript)

````
// ========== –£–°–¢–ê–ù–û–í–ö–ê ==========
/*
npm install web3
npm install ethers
npm install dotenv
*/

// ========== ETHERS.JS (–†–ï–ö–û–ú–ï–ù–î–£–ï–¢–°–Ø) ==========

const { ethers } = require('ethers');
require('dotenv').config();

// ========== –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö –ë–õ–û–ö–ß–ï–ô–ù–£ ==========

class BlockchainConnector {
    constructor(providerUrl, chainId = 1) {
        // –°–ø–æ—Å–æ–± 1: JSON-RPC Provider
        this.provider = new ethers.JsonRpcProvider(providerUrl, chainId);
        
        // –°–ø–æ—Å–æ–± 2: Infura/Alchemy Provider
        // this.provider = new ethers.InfuraProvider('mainnet', 'YOUR-API-KEY');
        // this.provider = new ethers.AlchemyProvider('mainnet', 'YOUR-API-KEY');
        
        // –°–ø–æ—Å–æ–± 3: –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MetaMask (–≤ –±—Ä–∞—É–∑–µ—Ä–µ)
        // this.provider = new ethers.BrowserProvider(window.ethereum);
    }
    
    async checkConnection() {
        try {
            const network = await this.provider.getNetwork();
            console.log('‚úÖ Connected to:', network.name);
            console.log('Chain ID:', network.chainId);
            return true;
        } catch (error) {
            console.error('‚ùå Connection failed:', error);
            return false;
        }
    }
}

// ========== –ë–ê–ó–û–í–´–ï –û–ü–ï–†–ê–¶–ò–ò ==========

async function basicOperations() {
    // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
    const provider = new ethers.JsonRpcProvider('https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY');
    
    // 1. –ü–û–õ–£–ß–ò–¢–¨ –ü–û–°–õ–ï–î–ù–ò–ô –ë–õ–û–ö
    const blockNumber = await provider.getBlockNumber();
    console.log('Latest block:', blockNumber);
    
    // 2. –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ë–õ–û–ö–ï
    const block = await provider.getBlock('latest');
    console.log('Block timestamp:', block.timestamp);
    console.log('Block hash:', block.hash);
    console.log('Transactions count:', block.transactions.length);
    
    // 3. –ü–û–õ–£–ß–ò–¢–¨ –ë–ê–õ–ê–ù–°
    const address = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'; // Vitalik
    const balance = await provider.getBalance(address);
    const balanceEth = ethers.formatEther(balance);
    console.log(`Balance: ${balanceEth} ETH`);
    
    // 4. –¶–ï–ù–ê –ì–ê–ó–ê
    const feeData = await provider.getFeeData();
    console.log('Gas Price:', ethers.formatUnits(feeData.gasPrice, 'gwei'), 'Gwei');
    console.log('Max Fee:', ethers.formatUnits(feeData.maxFeePerGas, 'gwei'), 'Gwei');
    
    // 5. –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –¢–†–ê–ù–ó–ê–ö–¶–ò–ò
    const txHash = '0x...';
    // const tx = await provider.getTransaction(txHash);
    // console.log('From:', tx.from);
    // console.log('To:', tx.to);
    // console.log('Value:', ethers.formatEther(tx.value), 'ETH');
    
    // 6. RECEIPT –¢–†–ê–ù–ó–ê–ö–¶–ò–ò
    // const receipt = await provider.getTransactionReceipt(txHash);
    // console.log('Status:', receipt.status === 1 ? 'Success' : 'Failed');
    // console.log('Gas used:', receipt.gasUsed.toString());
}

// ========== –†–ê–ë–û–¢–ê –° –ö–û–®–ï–õ–¨–ö–ê–ú–ò ==========

class WalletManager {
    // 1. –°–û–ó–î–ê–¢–¨ –ù–û–í–´–ô –ö–û–®–ï–õ–ï–ö
    static createWallet() {
        const wallet = ethers.Wallet.createRandom();
        return {
            address: wallet.address,
            privateKey: wallet.privateKey,
            mnemonic: wallet.mnemonic.phrase
        };
    }
    
    // 2. –ò–ú–ü–û–†–¢ –ü–û –ü–†–ò–í–ê–¢–ù–û–ú–£ –ö–õ–Æ–ß–£
    static fromPrivateKey(privateKey, provider) {
        return new ethers.Wallet(privateKey, provider);
    }
    
    // 3. –ò–ú–ü–û–†–¢ –ü–û –ú–ù–ï–ú–û–ù–ò–ö–ï
    static fromMnemonic(mnemonic, provider) {
        return ethers.Wallet.fromPhrase(mnemonic, provider);
    }
    
    // 4. –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö METAMASK (–≤ –±—Ä–∞—É–∑–µ—Ä–µ)
    static async connectMetaMask() {
        if (typeof window.ethereum === 'undefined') {
            throw new Error('MetaMask not installed');
        }
        
        const provider = new ethers.BrowserProvider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        const signer = await provider.getSigner();
        
        return {
            provider,
            signer,
            address: await signer.getAddress()
        };
    }
}

// –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
async function walletExample() {
    // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∫–æ—à–µ–ª–µ–∫
    const newWallet = WalletManager.createWallet();
    console.log('New Address:', newWallet.address);
    console.log('Private Key:', newWallet.privateKey);
    console.log('Mnemonic:', newWallet.mnemonic);
    
    // –í–ê–ñ–ù–û: –•—Ä–∞–Ω–∏—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ –∫–ª—é—á–∏ –≤ .env —Ñ–∞–π–ª–µ!
    
    // –ò–º–ø–æ—Ä—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ
    const provider = new ethers.JsonRpcProvider('http://127.0.0.1:8545');
    const wallet = WalletManager.fromPrivateKey(process.env.PRIVATE_KEY, provider);
    
    const balance = await provider.getBalance(wallet.address);
    console.log('Balance:', ethers.formatEther(balance), 'ETH');
}

// ========== –û–¢–ü–†–ê–í–ö–ê –¢–†–ê–ù–ó–ê–ö–¶–ò–ô ==========

class TransactionManager {
    constructor(wallet) {
        this.wallet = wallet;
        this.provider = wallet.provider;
    }
    
    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å ETH
    async sendEth(toAddress, amountEth) {
        const tx = {
            to: toAddress,
            value: ethers.parseEther(amountEth.toString())
        };
        
        console.log('Sending transaction...');
        const txResponse = await this.wallet.sendTransaction(tx);
        console.log('Transaction sent! Hash:', txResponse.hash);
        
        // –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
        const receipt = await txResponse.wait();
        
        if (receipt.status === 1) {
            console.log('‚úÖ Transaction successful!');
            console.log('Block:', receipt.blockNumber);
            console.log('Gas used:', receipt.gasUsed.toString());
        } else {
            console.log('‚ùå Transaction failed!');
        }
        
        return receipt;
    }
    
    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å –∫–∞—Å—Ç–æ–º–Ω—ã–º –≥–∞–∑–æ–º
    async sendEthWithGasOptions(toAddress, amountEth) {
        const feeData = await this.provider.getFeeData();
        
        const tx = {
            to: toAddress,
            value: ethers.parseEther(amountEth.toString()),
            gasLimit: 21000,
            maxFeePerGas: feeData.maxFeePerGas,
            maxPriorityFeePerGas: feeData.maxPriorityFeePerGas
        };
        
        const txResponse = await this.wallet.sendTransaction(tx);
        return await txResponse.wait();
    }
    
    // –û—Ü–µ–Ω–∏—Ç—å –≥–∞–∑
    async estimateGas(toAddress, amountEth) {
        const tx = {
            to: toAddress,
            value: ethers.parseEther(amountEth.toString())
        };
        
        const gasEstimate = await this.provider.estimateGas(tx);
        console.log('Estimated gas:', gasEstimate.toString());
        
        const feeData = await this.provider.getFeeData();
        const gasCost = gasEstimate * feeData.gasPrice;
        console.log('Estimated cost:', ethers.formatEther(gasCost), 'ETH');
        
        return gasEstimate;
    }
}

// ========== –†–ê–ë–û–¢–ê –°–û –°–ú–ê–†–¢-–ö–û–ù–¢–†–ê–ö–¢–ê–ú–ò ==========

class ContractManager {
    constructor(address, abi, signerOrProvider) {
        this.contract = new ethers.Contract(address, abi, signerOrProvider);
        this.address = address;
    }
    
    // –í—ã–∑–≤–∞—Ç—å view —Ñ—É–Ω–∫—Ü–∏—é (–Ω–µ —Ç—Ä–µ–±—É–µ—Ç –≥–∞–∑–∞)
    async callViewFunction(functionName, ...args) {
        try {
            const result = await this.contract[functionName](...args);
            return result;
        } catch (error) {
            console.error('Error calling function:', error);
            throw error;
        }
    }
    
    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é (–∏–∑–º–µ–Ω—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ)
    async sendTransaction(functionName, ...args) {
        try {
            const tx = await this.contract[functionName](...args);
            console.log('Transaction sent:', tx.hash);
            
            const receipt = await tx.wait();
            console.log('Transaction confirmed in block:', receipt.blockNumber);
            
            return {
                hash: tx.hash,
                receipt: receipt
            };
        } catch (error) {
            console.error('Transaction failed:', error);
            throw error;
        }
    }
    
    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å –∫–∞—Å—Ç–æ–º–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
    async sendTransactionWithOptions(functionName, args, options = {}) {
        const tx = await this.contract[functionName](...args, options);
        return await tx.wait();
    }
    
    // –û—Ü–µ–Ω–∏—Ç—å –≥–∞–∑
    async estimateGas(functionName, ...args) {
        const gasEstimate = await this.contract[functionName].estimateGas(...args);
        return gasEstimate;
    }
}

// ========== ERC-20 –ü–†–ò–ú–ï–† ==========

const ERC20_ABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)",
    "function totalSupply() view returns (uint256)",
    "function balanceOf(address) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)",
    "function approve(address spender, uint256 amount) returns (bool)",
    "function allowance(address owner, address spender) view returns (uint256)",
    "function transferFrom(address from, address to, uint256 amount) returns (bool)",
    "event Transfer(address indexed from, address indexed to, uint256 value)",
    "event Approval(address indexed owner, address indexed spender, uint256 value)"
];

async function erc20Example() {
    const provider = new ethers.JsonRpcProvider('https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY');
    
    // USDT –∫–æ–Ω—Ç—Ä–∞–∫—Ç
    const usdtAddress = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
    const usdt = new ContractManager(usdtAddress, ERC20_ABI, provider);
    
    // –ß–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    const name = await usdt.callViewFunction('name');
    const symbol = await usdt.callViewFunction('symbol');
    const decimals = await usdt.callViewFunction('decimals');
    const totalSupply = await usdt.callViewFunction('totalSupply');
    
    console.log(`Token: ${name} (${symbol})`);
    console.log(`Decimals: ${decimals}`);
    console.log(`Total Supply: ${ethers.formatUnits(totalSupply, decimals)} ${symbol}`);
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å
    const userAddress = '0x...';
    const balance = await usdt.callViewFunction('balanceOf', userAddress);
    console.log(`Balance: ${ethers.formatUnits(balance, decimals)} ${symbol}`);
    
    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–æ–∫–µ–Ω—ã (—Ç—Ä–µ–±—É–µ—Ç signer)
    // const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);
    // const usdtWithSigner = new ContractManager(usdtAddress, ERC20_ABI, wallet);
    // 
    // const recipient = '0x...';
    // const amount = ethers.parseUnits('100', decimals); // 100 USDT
    // 
    // await usdtWithSigner.sendTransaction('transfer', recipient, amount);
}

// ========== –°–õ–£–®–ê–¢–¨ –°–û–ë–´–¢–ò–Ø ==========

class EventListener {
    constructor(contract) {
        this.contract = contract;
    }
    
    // –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—à–ª—ã–µ —Å–æ–±—ã—Ç–∏—è
    async getPastEvents(eventName, fromBlock = 0, toBlock = 'latest') {
        const filter = this.contract.filters[eventName]();
        const events = await this.contract.queryFilter(filter, fromBlock, toBlock);
        return events;
    }
    
    // –°–ª—É—à–∞—Ç—å –Ω–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è
    listenForEvents(eventName, callback) {
        const filter = this.contract.filters[eventName]();
        
        this.contract.on(filter, (...args) => {
            const event = args[args.length - 1];
            callback(event);
        });
    }
    
    // –°–ª—É—à–∞—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ —Å —Ñ–∏–ª—å—Ç—Ä–æ–º
    listenWithFilter(eventName, filterParams, callback) {
        const filter = this.contract.filters[eventName](...filterParams);
        
        this.contract.on(filter, (...args) => {
            const event = args[args.length - 1];
            callback(event);
        });
    }
    
    // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ
    stopListening(eventName) {
        this.contract.removeAllListeners(eventName);
    }
}

// –ü—Ä–∏–º–µ—Ä –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è Transfer —Å–æ–±—ã—Ç–∏–π
async function eventExample() {
    const provider = new ethers.JsonRpcProvider('wss://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY');
    
    const usdtAddress = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
    const usdt = new ethers.Contract(usdtAddress, ERC20_ABI, provider);
    
    const listener = new EventListener(usdt);
    
    // –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—à–ª—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä—ã
    const pastTransfers = await listener.getPastEvents('Transfer', 18000000, 18001000);
    
    console.log(`Found ${pastTransfers.length} transfers`);
    pastTransfers.slice(0, 5).forEach(event => {
        console.log('---');
        console.log('From:', event.args.from);
        console.log('To:', event.args.to);
        console.log('Amount:', ethers.formatUnits(event.args.value, 6));
        console.log('Block:', event.blockNumber);
    });
    
    // –°–ª—É—à–∞—Ç—å –Ω–æ–≤—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä—ã
    console.log('\nListening for new transfers...');
    listener.listenForEvents('Transfer', (event) => {
        console.log('New Transfer!');
        console.log('From:', event.args.from);
        console.log('To:', event.args.to);
        console.log('Amount:', ethers.formatUnits(event.args.value, 6));
    });
}

// ========== –î–ï–ü–õ–û–ô –ö–û–ù–¢–†–ê–ö–¢–ê ==========

async function deployContract(wallet, bytecode, abi, constructorArgs = []) {
    const factory = new ethers.ContractFactory(abi, bytecode, wallet);
    
    console.log('Deploying contract...');
    const contract = await factory.deploy(...constructorArgs);
    
    console.log('Deploy transaction sent:', contract.deploymentTransaction().hash);
    console.log('Waiting for confirmation...');
    
    await contract.waitForDeployment();
    
    const address = await contract.getAddress();
    console.log('‚úÖ Contract deployed at:', address);
    
    return contract;
}

// ========== –ü–û–î–ü–ò–°–ê–ù–ò–ï –°–û–û–ë–©–ï–ù–ò–ô ==========

class MessageSigner {
    constructor(wallet) {
        this.wallet = wallet;
    }
    
    // –ü–æ–¥–ø–∏—Å–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
    async signMessage(message) {
        const signature = await this.wallet.signMessage(message);
        return signature;
    }
    
    // –ü–æ–¥–ø–∏—Å–∞—Ç—å —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (EIP-712)
    async signTypedData(domain, types, value) {
        const signature = await this.wallet.signTypedData(domain, types, value);
        return signature;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å—å
    static verifyMessage(message, signature) {
        const address = ethers.verifyMessage(message, signature);
        return address;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—É—é –ø–æ–¥–ø–∏—Å—å
    static verifyTypedData(domain, types, value, signature) {
        const address = ethers.verifyTypedData(domain, types, value, signature);
        return address;
    }
}

// –ü—Ä–∏–º–µ—Ä –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è
async function signingExample() {
    const wallet = ethers.Wallet.createRandom();
    const signer = new MessageSigner(wallet);
    
    // –ü–æ–¥–ø–∏—Å–∞—Ç—å –ø—Ä–æ—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    const message = "Hello, Blockchain!";
    const signature = await signer.signMessage(message);
    console.log('Signature:', signature);
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å—å
    const recoveredAddress = MessageSigner.verifyMessage(message, signature);
    console.log('Signer address:', recoveredAddress);
    console.log('Match:', recoveredAddress === wallet.address);
    
    // EIP-712 —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–¥–ø–∏—Å—å
    const domain = {
        name: 'MyDApp',
        version: '1',
        chainId: 1,
        verifyingContract: '0x...'
    };
    
    const types = {
        Person: [
            { name: 'name', type: 'string' },
            { name: 'wallet', type: 'address' }
        ]
    };
    
    const value = {
        name: 'Alice',
        wallet: '0x...'
    };
    
    const typedSignature = await signer.signTypedData(domain, types, value);
    console.log('Typed Signature:', typedSignature);
}

// ========== MULTICALL (BATCH –ó–ê–ü–†–û–°–´) ==========

async function multicallExample() {
    const provider = new ethers.JsonRpcProvider('https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY');
    
    // –ú–∞—Å—Å–∏–≤ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤
    const tokens = [
        '0xdAC17F958D2ee523a2206206994597C13D831ec7', // USDT
        '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC
        '0x6B175474E89094C44Da98b954EedeAC495271d0F'  // DAI
    ];
    
    // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
    const balances = await Promise.all(
        tokens.map(async (tokenAddress) => {
            const token = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
            const symbol = await token.symbol();
            const balance = await token.balanceOf('0x...');
            return { symbol, balance };
        })
    );
    
    balances.forEach(({ symbol, balance }) => {
        console.log(`${symbol}: ${ethers.formatUnits(balance, 18)}`);
    });
}

// ========== –£–¢–ò–õ–ò–¢–´ ==========

class Utils {
    // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –µ–¥–∏–Ω–∏—Ü
    static toWei(amount, unit = 'ether') {
        return ethers.parseUnits(amount.toString(), unit);
    }
    
    static fromWei(amount, unit = 'ether') {
        return ethers.formatUnits(amount, unit);
    }
    
    // –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ
    static keccak256(data) {
        return ethers.keccak256(ethers.toUtf8Bytes(data));
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥—Ä–µ—Å–∞
    static isAddress(address) {
        return ethers.isAddress(address);
    }
    
    // Checksum –∞–¥—Ä–µ—Å
    static getAddress(address) {
        return ethers.getAddress(address);
    }
    
    // –°–æ–∑–¥–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–µ bytes
    static randomBytes(length) {
        return ethers.randomBytes(length);
    }
    
    // –ö–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—è bytes
    static concat(arrays) {
        return ethers.concat(arrays);
    }
}

// ========== REACT –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø ==========

// –ü—Ä–∏–º–µ—Ä React —Ö—É–∫–∞ –¥–ª—è Web3
/*
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';

function useWeb3() {
    const [provider, setProvider] = useState(null);
    const [signer, setSigner] = useState(null);
    const [address, setAddress] = useState(null);
    const [connected, setConnected] = useState(false);
    
    const connect = async () => {
        if (typeof window.ethereum === 'undefined') {
            alert('Please install MetaMask!');
            return;
        }
        
        try {
            const provider = new ethers.BrowserProvider(window.ethereum);
            await provider.send("eth_requestAccounts", []);
            const signer = await provider.getSigner();
            const address = await signer.getAddress();
            
            setProvider(provider);
            setSigner(signer);
            setAddress(address);
            setConnected(true);
        } catch (error) {
            console.error('Connection failed:', error);
        }
    };
    
    const disconnect = () => {
        setProvider(null);
        setSigner(null);
        setAddress(null);
        setConnected(false);
    };
    
    return { provider, signer, address, connected, connect, disconnect };
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–µ
function App() {
    const { address, connected, connect, disconnect } = useWeb3();
    
    return (
        <div>
            {!connected ? (
                <button onClick={connect}>Connect Wallet</button>
            ) : (
                <div>
                    <p>Connected: {address}</p>
                    <button onClick={disconnect}>Disconnect</button>
                </div>
            )}
        </div>
    );
}
*/

// ========== –≠–ö–°–ü–û–†–¢ ==========

module.exports = {
    BlockchainConnector,
    WalletManager,
    TransactionManager,
    ContractManager,
    EventListener,
    MessageSigner,
    Utils
};

// –ü—Ä–∏–º–µ—Ä—ã –∑–∞–ø—É—Å–∫–∞
if (require.main === module) {
    console.log('Ethers.js Examples');
    console.log('=' + '='.repeat(50));
    
    // basicOperations();
    // walletExample();
    // erc20Example();
    // eventExample();
}
````

## DApp —Å —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–æ–º –∏ –±—ç–∫–µ–Ω–¥–æ–º

````
# üöÄ –ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π DApp: NFT Marketplace

## –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

```
nft-marketplace/
‚îú‚îÄ‚îÄ contracts/          # Solidity —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã
‚îÇ   ‚îú‚îÄ‚îÄ NFT.sol
‚îÇ   ‚îî‚îÄ‚îÄ Marketplace.sol
‚îú‚îÄ‚îÄ backend/           # Python/Node.js backend
‚îÇ   ‚îú‚îÄ‚îÄ server.py
‚îÇ   ‚îî‚îÄ‚îÄ indexer.py
‚îú‚îÄ‚îÄ frontend/          # React frontend
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ scripts/           # –°–∫—Ä–∏–ø—Ç—ã –¥–µ–ø–ª–æ—è
‚îÇ   ‚îú‚îÄ‚îÄ deploy.py
‚îÇ   ‚îî‚îÄ‚îÄ deploy.js
‚îî‚îÄ‚îÄ tests/            # –¢–µ—Å—Ç—ã
    ‚îú‚îÄ‚îÄ test_contracts.py
    ‚îî‚îÄ‚îÄ test_contracts.js
```

---

## üìù 1. Backend API (Python + Flask)

```python
# backend/server.py

from flask import Flask, jsonify, request
from flask_cors import CORS
from web3 import Web3
from eth_account import Account
import json
import os
from dotenv import load_dotenv

load_dotenv()

app = Flask(__name__)
CORS(app)

# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–ª–æ–∫—á–µ–π–Ω—É
w3 = Web3(Web3.HTTPProvider(os.getenv('RPC_URL')))

# –ó–∞–≥—Ä—É–∑–∫–∞ ABI –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤
with open('abi/NFT.json') as f:
    NFT_ABI = json.load(f)

with open('abi/Marketplace.json') as f:
    MARKETPLACE_ABI = json.load(f)

# –ê–¥—Ä–µ—Å–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤
NFT_ADDRESS = os.getenv('NFT_CONTRACT_ADDRESS')
MARKETPLACE_ADDRESS = os.getenv('MARKETPLACE_CONTRACT_ADDRESS')

# –ö–æ–Ω—Ç—Ä–∞–∫—Ç—ã
nft_contract = w3.eth.contract(address=NFT_ADDRESS, abi=NFT_ABI)
marketplace_contract = w3.eth.contract(address=MARKETPLACE_ADDRESS, abi=MARKETPLACE_ABI)

# ========== API ENDPOINTS ==========

@app.route('/api/nfts', methods=['GET'])
def get_all_nfts():
    """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ NFT"""
    try:
        total_supply = nft_contract.functions.totalSupply().call()
        nfts = []
        
        for token_id in range(total_supply):
            owner = nft_contract.functions.ownerOf(token_id).call()
            token_uri = nft_contract.functions.tokenURI(token_id).call()
            
            nfts.append({
                'tokenId': token_id,
                'owner': owner,
                'tokenURI': token_uri
            })
        
        return jsonify({'success': True, 'nfts': nfts})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/nft/<int:token_id>', methods=['GET'])
def get_nft(token_id):
    """–ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± NFT"""
    try:
        owner = nft_contract.functions.ownerOf(token_id).call()
        token_uri = nft_contract.functions.tokenURI(token_id).call()
        
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –≤—ã—Å—Ç–∞–≤–ª–µ–Ω –ª–∏ –Ω–∞ –ø—Ä–æ–¥–∞–∂—É
        listing = marketplace_contract.functions.listings(token_id).call()
        
        return jsonify({
            'success': True,
            'tokenId': token_id,
            'owner': owner,
            'tokenURI': token_uri,
            'listing': {
                'price': listing[0],
                'seller': listing[1],
                'active': listing[2]
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/marketplace/listings', methods=['GET'])
def get_listings():
    """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –ª–∏—Å—Ç–∏–Ω–≥–∏"""
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Å–æ–±—ã—Ç–∏—è Listing
        event_filter = marketplace_contract.events.Listed.create_filter(
            fromBlock=0,
            toBlock='latest'
        )
        
        events = event_filter.get_all_entries()
        active_listings = []
        
        for event in events:
            token_id = event['args']['tokenId']
            listing = marketplace_contract.functions.listings(token_id).call()
            
            if listing[2]:  # –µ—Å–ª–∏ active
                nft_uri = nft_contract.functions.tokenURI(token_id).call()
                active_listings.append({
                    'tokenId': token_id,
                    'price': listing[0],
                    'seller': listing[1],
                    'tokenURI': nft_uri
                })
        
        return jsonify({'success': True, 'listings': active_listings})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/user/<address>/nfts', methods=['GET'])
def get_user_nfts(address):
    """–ü–æ–ª—É—á–∏—Ç—å NFT –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        balance = nft_contract.functions.balanceOf(address).call()
        user_nfts = []
        
        total_supply = nft_contract.functions.totalSupply().call()
        
        for token_id in range(total_supply):
            owner = nft_contract.functions.ownerOf(token_id).call()
            if owner.lower() == address.lower():
                token_uri = nft_contract.functions.tokenURI(token_id).call()
                user_nfts.append({
                    'tokenId': token_id,
                    'tokenURI': token_uri
                })
        
        return jsonify({'success': True, 'nfts': user_nfts})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/stats', methods=['GET'])
def get_stats():
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–∞"""
    try:
        total_supply = nft_contract.functions.totalSupply().call()
        
        # –ü–æ–¥—Å—á–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ª–∏—Å—Ç–∏–Ω–≥–æ–≤
        active_count = 0
        total_volume = 0
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–æ–±—ã—Ç–∏—è Sold –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ –æ–±—ä–µ–º–∞
        sold_events = marketplace_contract.events.Sold.create_filter(
            fromBlock=0,
            toBlock='latest'
        ).get_all_entries()
        
        for event in sold_events:
            total_volume += event['args']['price']
        
        return jsonify({
            'success': True,
            'stats': {
                'totalNFTs': total_supply,
                'totalVolume': total_volume,
                'activeListings': active_count
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

---

## üé® 2. Frontend (React + Ethers.js)

```javascript
// frontend/src/App.jsx

import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import NFTCard from './components/NFTCard';
import Navbar from './components/Navbar';
import './App.css';

// Import ABIs
import NFT_ABI from './contracts/NFT.json';
import MARKETPLACE_ABI from './contracts/Marketplace.json';

const NFT_ADDRESS = process.env.REACT_APP_NFT_ADDRESS;
const MARKETPLACE_ADDRESS = process.env.REACT_APP_MARKETPLACE_ADDRESS;

function App() {
    const [provider, setProvider] = useState(null);
    const [signer, setSigner] = useState(null);
    const [account, setAccount] = useState(null);
    const [nftContract, setNftContract] = useState(null);
    const [marketplaceContract, setMarketplaceContract] = useState(null);
    const [listings, setListings] = useState([]);
    const [userNFTs, setUserNFTs] = useState([]);
    const [loading, setLoading] = useState(false);

    // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–∞
    const connectWallet = async () => {
        try {
            if (typeof window.ethereum === 'undefined') {
                alert('Please install MetaMask!');
                return;
            }

            const provider = new ethers.BrowserProvider(window.ethereum);
            await provider.send("eth_requestAccounts", []);
            const signer = await provider.getSigner();
            const address = await signer.getAddress();

            setProvider(provider);
            setSigner(signer);
            setAccount(address);

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤
            const nft = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
            const marketplace = new ethers.Contract(MARKETPLACE_ADDRESS, MARKETPLACE_ABI, signer);

            setNftContract(nft);
            setMarketplaceContract(marketplace);

            console.log('Connected:', address);
        } catch (error) {
            console.error('Connection failed:', error);
        }
    };

    // –ó–∞–≥—Ä—É–∑–∫–∞ –ª–∏—Å—Ç–∏–Ω–≥–æ–≤
    const loadListings = async () => {
        if (!marketplaceContract) return;

        setLoading(true);
        try {
            const response = await fetch('http://localhost:5000/api/marketplace/listings');
            const data = await response.json();

            if (data.success) {
                setListings(data.listings);
            }
        } catch (error) {
            console.error('Error loading listings:', error);
        }
        setLoading(false);
    };

    // –ó–∞–≥—Ä—É–∑–∫–∞ NFT –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const loadUserNFTs = async () => {
        if (!account) return;

        try {
            const response = await fetch(`http://localhost:5000/api/user/${account}/nfts`);
            const data = await response.json();

            if (data.success) {
                setUserNFTs(data.nfts);
            }
        } catch (error) {
            console.error('Error loading user NFTs:', error);
        }
    };

    // –ú–∏–Ω—Ç NFT
    const mintNFT = async (tokenURI) => {
        if (!nftContract) return;

        try {
            setLoading(true);
            const tx = await nftContract.mint(account, tokenURI);
            await tx.wait();
            alert('NFT minted successfully!');
            loadUserNFTs();
        } catch (error) {
            console.error('Mint failed:', error);
            alert('Mint failed: ' + error.message);
        }
        setLoading(false);
    };

    // –í—ã—Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –ø—Ä–æ–¥–∞–∂—É
    const listNFT = async (tokenId, price) => {
        if (!marketplaceContract || !nftContract) return;

        try {
            setLoading(true);

            // 1. Approve marketplace
            const approveTx = await nftContract.approve(MARKETPLACE_ADDRESS, tokenId);
            await approveTx.wait();

            // 2. List –Ω–∞ marketplace
            const priceWei = ethers.parseEther(price.toString());
            const listTx = await marketplaceContract.listNFT(NFT_ADDRESS, tokenId, priceWei);
            await listTx.wait();

            alert('NFT listed successfully!');
            loadListings();
            loadUserNFTs();
        } catch (error) {
            console.error('Listing failed:', error);
            alert('Listing failed: ' + error.message);
        }
        setLoading(false);
    };

    // –ö—É–ø–∏—Ç—å NFT
    const buyNFT = async (tokenId, price) => {
        if (!marketplaceContract) return;

        try {
            setLoading(true);
            const tx = await marketplaceContract.buyNFT(tokenId, { value: price });
            await tx.wait();
            alert('NFT purchased successfully!');
            loadListings();
            loadUserNFTs();
        } catch (error) {
            console.error('Purchase failed:', error);
            alert('Purchase failed: ' + error.message);
        }
        setLoading(false);
    };

    useEffect(() => {
        if (marketplaceContract) {
            loadListings();
        }
    }, [marketplaceContract]);

    useEffect(() => {
        if (account) {
            loadUserNFTs();
        }
    }, [account]);

    return (
        <div className="App">
            <Navbar 
                account={account} 
                connectWallet={connectWallet}
            />

            <div className="container">
                {/* –°–µ–∫—Ü–∏—è –º–∏–Ω—Ç–∞ */}
                <section className="mint-section">
                    <h2>Mint NFT</h2>
                    <button 
                        onClick={() => mintNFT('ipfs://...')}
                        disabled={loading || !account}
                    >
                        {loading ? 'Minting...' : 'Mint NFT'}
                    </button>
                </section>

                {/* –ú–æ–∏ NFT */}
                <section className="my-nfts">
                    <h2>My NFTs</h2>
                    <div className="nft-grid">
                        {userNFTs.map(nft => (
                            <NFTCard
                                key={nft.tokenId}
                                nft={nft}
                                onList={listNFT}
                                owned={true}
                            />
                        ))}
                    </div>
                </section>

                {/* Marketplace –ª–∏—Å—Ç–∏–Ω–≥–∏ */}
                <section className="marketplace">
                    <h2>Marketplace</h2>
                    <div className="nft-grid">
                        {listings.map(listing => (
                            <NFTCard
                                key={listing.tokenId}
                                nft={listing}
                                onBuy={buyNFT}
                                owned={false}
                            />
                        ))}
                    </div>
                </section>
            </div>
        </div>
    );
}

export default App;
```

---

## üîß 3. Custom React Hooks

```javascript
// frontend/src/hooks/useWeb3.js

import { useState, useEffect } from 'react';
import { ethers } from 'ethers';

export const useWeb3 = () => {
    const [provider, setProvider] = useState(null);
    const [signer, setSigner] = useState(null);
    const [account, setAccount] = useState(null);
    const [chainId, setChainId] = useState(null);
    const [balance, setBalance] = useState('0');

    const connect = async () => {
        if (typeof window.ethereum === 'undefined') {
            throw new Error('MetaMask not installed');
        }

        const provider = new ethers.BrowserProvider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        const signer = await provider.getSigner();
        const address = await signer.getAddress();
        const network = await provider.getNetwork();
        const balance = await provider.getBalance(address);

        setProvider(provider);
        setSigner(signer);
        setAccount(address);
        setChainId(Number(network.chainId));
        setBalance(ethers.formatEther(balance));
    };

    const disconnect = () => {
        setProvider(null);
        setSigner(null);
        setAccount(null);
        setChainId(null);
        setBalance('0');
    };

    // –°–ª—É—à–∞—Ç—å —Å–º–µ–Ω—É –∞–∫–∫–∞—É–Ω—Ç–∞
    useEffect(() => {
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length > 0) {
                    connect();
                } else {
                    disconnect();
                }
            });

            window.ethereum.on('chainChanged', () => {
                window.location.reload();
            });
        }

        return () => {
            if (window.ethereum) {
                window.ethereum.removeAllListeners('accountsChanged');
                window.ethereum.removeAllListeners('chainChanged');
            }
        };
    }, []);

    return {
        provider,
        signer,
        account,
        chainId,
        balance,
        connect,
        disconnect
    };
};
```

```javascript
// frontend/src/hooks/useContract.js

import { useState, useEffect } from 'react';
import { ethers } from 'ethers';

export const useContract = (address, abi, signer) => {
    const [contract, setContract] = useState(null);

    useEffect(() => {
        if (address && abi && signer) {
            const contract = new ethers.Contract(address, abi, signer);
            setContract(contract);
        }
    }, [address, abi, signer]);

    return contract;
};
```

---

## üß™ 4. –°–∫—Ä–∏–ø—Ç—ã –¥–µ–ø–ª–æ—è

```python
# scripts/deploy.py (Brownie/Ape)

from ape import accounts, project

def deploy():
    # –ü–æ–ª—É—á–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç
    deployer = accounts.load("deployer")
    
    # –î–µ–ø–ª–æ–π NFT –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
    nft = project.NFT.deploy(
        "MyNFT",
        "MNFT",
        sender=deployer
    )
    print(f"NFT deployed at: {nft.address}")
    
    # –î–µ–ø–ª–æ–π Marketplace –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
    marketplace = project.Marketplace.deploy(sender=deployer)
    print(f"Marketplace deployed at: {marketplace.address}")
    
    return nft, marketplace

if __name__ == "__main__":
    deploy()
```

```javascript
// scripts/deploy.js (Hardhat)

const hre = require("hardhat");

async function main() {
    const [deployer] = await hre.ethers.getSigners();
    console.log("Deploying with:", deployer.address);

    // Deploy NFT
    const NFT = await hre.ethers.getContractFactory("NFT");
    const nft = await NFT.deploy("MyNFT", "MNFT");
    await nft.waitForDeployment();
    console.log("NFT deployed to:", await nft.getAddress());

    // Deploy Marketplace
    const Marketplace = await hre.ethers.getContractFactory("Marketplace");
    const marketplace = await Marketplace.deploy();
    await marketplace.waitForDeployment();
    console.log("Marketplace deployed to:", await marketplace.getAddress());
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
```

---

## üìã –†–µ–∑—é–º–µ

**–°—Ç–µ–∫ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π:**
- **–°–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã:** Solidity
- **Backend:** Python (Flask) / Node.js (Express)
- **Frontend:** React + Ethers.js
- **Database:** PostgreSQL / MongoDB (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
- **IPFS:** –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è metadata
- **Deployment:** Hardhat / Foundry

**–ö–ª—é—á–µ–≤—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏:**
1. ‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–ª–æ–∫—á–µ–π–Ω—É (Web3.py, Ethers.js)
2. ‚úÖ –†–∞–±–æ—Ç–∞ —Å –∫–æ—à–µ–ª—å–∫–∞–º–∏ (—Å–æ–∑–¥–∞–Ω–∏–µ, –∏–º–ø–æ—Ä—Ç)
3. ‚úÖ –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
4. ‚úÖ –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å–æ —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞–º–∏
5. ‚úÖ –ü—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π
6. ‚úÖ React hooks –¥–ª—è Web3
7. ‚úÖ Backend API –¥–ª—è –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏
8. ‚úÖ –ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π DApp

–¢–µ–ø–µ—Ä—å —É –≤–∞—Å –µ—Å—Ç—å –ø–æ–ª–Ω—ã–π –Ω–∞–±–æ—Ä –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è Web3 –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π!
````

# üéØ Web3 Development: Best Practices & –ß–µ–∫–ª–∏—Å—Ç

## üìö –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫

````
| –§—É–Ω–∫—Ü–∏—è           | Web3.py (Python) | Web3.js  | Ethers.js     |
|-------------------|------------------|----------|---------------|
| **–ü–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç—å**  | ‚≠ê‚≠ê‚≠ê          | ‚≠ê‚≠ê‚≠ê‚≠ê| ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê   |
| **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**  | –•–æ—Ä–æ—à–∞—è          | –°—Ä–µ–¥–Ω—è—è  | –û—Ç–ª–∏—á–Ω–∞—è      |
| **–†–∞–∑–º–µ—Ä**        | –°—Ä–µ–¥–Ω–∏–π          | –ë–æ–ª—å—à–æ–π  | –ú–∞–ª–µ–Ω—å–∫–∏–π     |
| **TypeScript**    | ‚ùå               | –ß–∞—Å—Ç–∏—á–Ω–æ | ‚úÖ             |
| **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ** | Backend/Scripts  | Legacy   | –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è |
| **ENS Support**   | ‚úÖ               | ‚úÖ       | ‚úÖ             |
| **–ü–æ–¥–ø–∏—Å–∞–Ω–∏–µ**    | ‚úÖ               | ‚úÖ       | ‚úÖ             |

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** 
- **Frontend**: Ethers.js (v6)
- **Backend**: Web3.py (Python) –∏–ª–∏ Ethers.js (Node.js)
- **Scripts**: –õ—é–±–∞—è

---

## üîê –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

### 1. –•—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö –∫–ª—é—á–µ–π

```bash
# ‚ùå –ù–ò–ö–û–ì–î–ê –ù–ï –î–ï–õ–ê–ô–¢–ï –¢–ê–ö
const privateKey = "0x1234..."; // –≤ –∫–æ–¥–µ

# ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: .env —Ñ–∞–π–ª
PRIVATE_KEY=0x1234...
RPC_URL=https://...
CONTRACT_ADDRESS=0x...
```

```python
# Python
from dotenv import load_dotenv
import os

load_dotenv()
private_key = os.getenv('PRIVATE_KEY')
```

```javascript
// JavaScript
require('dotenv').config();
const privateKey = process.env.PRIVATE_KEY;
```

### 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

```javascript
// ‚ùå –ü–õ–û–•–û
async function transfer(to, amount) {
    await token.transfer(to, amount);
}

// ‚úÖ –•–û–†–û–®–û
async function transfer(to, amount) {
    if (!ethers.isAddress(to)) {
        throw new Error('Invalid address');
    }
    if (amount <= 0) {
        throw new Error('Amount must be positive');
    }
    try {
        const tx = await token.transfer(to, amount);
        return await tx.wait();
    } catch (error) {
        console.error('Transfer failed:', error);
        throw error;
    }
}
```

### 3. Rate Limiting –¥–ª—è RPC

```python
import time
from functools import wraps

def rate_limit(calls_per_second=5):
    min_interval = 1.0 / calls_per_second
    last_called = [0.0]
    
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            elapsed = time.time() - last_called[0]
            if elapsed < min_interval:
                time.sleep(min_interval - elapsed)
            result = func(*args, **kwargs)
            last_called[0] = time.time()
            return result
        return wrapper
    return decorator

@rate_limit(calls_per_second=5)
def get_balance(address):
    return w3.eth.get_balance(address)
```

---

## ‚ö° –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

### 1. –ë–∞—Ç—á–∏–Ω–≥ –∑–∞–ø—Ä–æ—Å–æ–≤

```javascript
// ‚ùå –ü–õ–û–•–û: –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
async function getBalances(addresses) {
    const balances = [];
    for (const addr of addresses) {
        const balance = await provider.getBalance(addr);
        balances.push(balance);
    }
    return balances;
}

// ‚úÖ –•–û–†–û–®–û: –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
async function getBalances(addresses) {
    return await Promise.all(
        addresses.map(addr => provider.getBalance(addr))
    );
}
```

### 2. –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ

```python
from functools import lru_cache
import time

@lru_cache(maxsize=128)
def get_token_info(token_address):
    """–ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–∞"""
    contract = w3.eth.contract(address=token_address, abi=ERC20_ABI)
    return {
        'name': contract.functions.name().call(),
        'symbol': contract.functions.symbol().call(),
        'decimals': contract.functions.decimals().call()
    }

# –° –≤—Ä–µ–º–µ–Ω–Ω—ã–º –∫–µ—à–µ–º
class TimedCache:
    def __init__(self, ttl_seconds=60):
        self.cache = {}
        self.ttl = ttl_seconds
    
    def get(self, key):
        if key in self.cache:
            value, timestamp = self.cache[key]
            if time.time() - timestamp < self.ttl:
                return value
            del self.cache[key]
        return None
    
    def set(self, key, value):
        self.cache[key] = (value, time.time())
```

### 3. Pagination –¥–ª—è —Å–æ–±—ã—Ç–∏–π

```javascript
// ‚ùå –ü–õ–û–•–û: –í—Å–µ —Å–æ–±—ã—Ç–∏—è —Å—Ä–∞–∑—É
const events = await contract.queryFilter('Transfer', 0, 'latest');

// ‚úÖ –•–û–†–û–®–û: –ü–æ –±–ª–æ–∫–∞–º
async function getEventsInChunks(contract, eventName, fromBlock, toBlock, chunkSize = 10000) {
    const events = [];
    
    for (let i = fromBlock; i <= toBlock; i += chunkSize) {
        const endBlock = Math.min(i + chunkSize - 1, toBlock);
        const chunk = await contract.queryFilter(eventName, i, endBlock);
        events.push(...chunk);
    }
    
    return events;
}
```

---

## üîÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫

### 1. –ü–æ–≤—Ç–æ—Ä–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏

```python
import time
from functools import wraps

def retry(max_attempts=3, delay=1):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise
                    print(f"Attempt {attempt + 1} failed: {e}")
                    time.sleep(delay * (2 ** attempt))  # Exponential backoff
        return wrapper
    return decorator

@retry(max_attempts=3, delay=1)
def send_transaction(tx):
    return w3.eth.send_raw_transaction(tx)
```

### 2. Graceful degradation

```javascript
async function getGasPrice() {
    try {
        // –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å –æ—Ç –æ—Ä–∞–∫—É–ª–∞
        const gasPrice = await gasOracle.getGasPrice();
        return gasPrice;
    } catch (error) {
        console.warn('Gas oracle failed, using provider gas price');
        try {
            // Fallback –Ω–∞ –ø—Ä–æ–≤–∞–π–¥–µ—Ä
            return await provider.getFeeData();
        } catch (error2) {
            console.error('All gas price sources failed');
            // Hardcoded fallback
            return {
                gasPrice: ethers.parseUnits('50', 'gwei'),
                maxFeePerGas: ethers.parseUnits('100', 'gwei'),
                maxPriorityFeePerGas: ethers.parseUnits('2', 'gwei')
            };
        }
    }
}
```

---

## üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ

### 1. –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ

```python
import logging
import json

class Web3Logger:
    def __init__(self):
        self.logger = logging.getLogger('web3_app')
        handler = logging.StreamHandler()
        handler.setFormatter(
            logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        )
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)
    
    def log_transaction(self, tx_hash, status, gas_used):
        self.logger.info(json.dumps({
            'event': 'transaction',
            'tx_hash': tx_hash,
            'status': status,
            'gas_used': gas_used
        }))
    
    def log_error(self, error, context):
        self.logger.error(json.dumps({
            'event': 'error',
            'error': str(error),
            'context': context
        }))
```

### 2. –ú–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

```javascript
class PerformanceMonitor {
    constructor() {
        this.metrics = {};
    }
    
    async measure(name, fn) {
        const start = Date.now();
        try {
            const result = await fn();
            const duration = Date.now() - start;
            
            if (!this.metrics[name]) {
                this.metrics[name] = {
                    count: 0,
                    totalTime: 0,
                    avgTime: 0
                };
            }
            
            this.metrics[name].count++;
            this.metrics[name].totalTime += duration;
            this.metrics[name].avgTime = 
                this.metrics[name].totalTime / this.metrics[name].count;
            
            return result;
        } catch (error) {
            console.error(`Error in ${name}:`, error);
            throw error;
        }
    }
    
    getMetrics() {
        return this.metrics;
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
const monitor = new PerformanceMonitor();

const balance = await monitor.measure('getBalance', async () => {
    return await provider.getBalance(address);
});

console.log(monitor.getMetrics());
```

---

## üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### 1. Unit —Ç–µ—Å—Ç—ã (Python)

```python
import pytest
from web3 import Web3

@pytest.fixture
def w3():
    return Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))

@pytest.fixture
def accounts(w3):
    return w3.eth.accounts

def test_send_transaction(w3, accounts):
    tx = {
        'from': accounts[0],
        'to': accounts[1],
        'value': w3.to_wei(1, 'ether'),
        'gas': 21000,
        'gasPrice': w3.eth.gas_price
    }
    
    tx_hash = w3.eth.send_transaction(tx)
    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    
    assert receipt['status'] == 1
```

### 2. Integration —Ç–µ—Å—Ç—ã (JavaScript)

```javascript
const { expect } = require('chai');
const { ethers } = require('hardhat');

describe('Token', function() {
    let token;
    let owner;
    let addr1;
    
    beforeEach(async function() {
        [owner, addr1] = await ethers.getSigners();
        const Token = await ethers.getContractFactory('Token');
        token = await Token.deploy(1000000);
    });
    
    it('Should transfer tokens', async function() {
        await token.transfer(addr1.address, 100);
        expect(await token.balanceOf(addr1.address)).to.equal(100);
    });
    
    it('Should fail if sender has insufficient balance', async function() {
        await expect(
            token.connect(addr1).transfer(owner.address, 100)
        ).to.be.revertedWith('Insufficient balance');
    });
});
```

---

## üìù –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –∫–æ–¥–∞

```javascript
/**
 * Transfers tokens to a recipient
 * 
 * @param {string} recipient - The recipient's address
 * @param {number|string} amount - Amount of tokens to transfer
 * @returns {Promise<TransactionReceipt>} Transaction receipt
 * @throws {Error} If address is invalid or amount is negative
 * 
 * @example
 * const receipt = await transferTokens('0x...', '100');
 * console.log('Transfer successful:', receipt.hash);
 */
async function transferTokens(recipient, amount) {
    if (!ethers.isAddress(recipient)) {
        throw new Error('Invalid recipient address');
    }
    
    const tx = await token.transfer(recipient, ethers.parseEther(amount));
    return await tx.wait();
}
```

---

## ‚úÖ –ß–µ–∫–ª–∏—Å—Ç –ø–µ—Ä–µ–¥ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–æ–º

### –°–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã
- [ ] –ê—É–¥–∏—Ç –∫–æ–¥–∞
- [ ] –¢–µ—Å—Ç—ã (–º–∏–Ω–∏–º—É–º 80% –ø–æ–∫—Ä—ã—Ç–∏–µ)
- [ ] –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∏–∑–≤–µ—Å—Ç–Ω—ã–µ —É—è–∑–≤–∏–º–æ—Å—Ç–∏
- [ ] –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ testnet
- [ ] Verify –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –Ω–∞ Etherscan
- [ ] –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

### Backend/Frontend
- [ ] –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö –æ—à–∏–±–æ–∫
- [ ] Rate limiting –¥–ª—è API
- [ ] –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- [ ] –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–ª—é—á–µ–π
- [ ] –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
- [ ] –†–µ–∑–µ—Ä–≤–Ω—ã–µ RPC –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã
- [ ] CORS –ø—Ä–∞–≤–∏–ª—å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω
- [ ] HTTPS –¥–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞

### –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å
- [ ] –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –∫–ª—é—á–∏ –≤ .env
- [ ] .gitignore –¥–ª—è —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
- [ ] Multisig –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
- [ ] Timelock –¥–ª—è –≤–∞–∂–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π
- [ ] –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –≤–Ω–µ—à–Ω–∏—Ö –≤–≤–æ–¥–æ–≤
- [ ] –ó–∞—â–∏—Ç–∞ –æ—Ç CSRF/XSS

### –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
- [ ] –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
- [ ] –ë–∞—Ç—á–∏–Ω–≥ –∑–∞–ø—Ä–æ—Å–æ–≤
- [ ] Pagination –¥–ª—è –±–æ–ª—å—à–∏—Ö —Å–ø–∏—Å–∫–æ–≤
- [ ] –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≥–∞–∑–∞
- [ ] CDN –¥–ª—è —Å—Ç–∞—Ç–∏–∫–∏
- [ ] Compression –¥–ª—è API

### UX
- [ ] Loading –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
- [ ] –ü–æ–Ω—è—Ç–Ω—ã–µ error —Å–æ–æ–±—â–µ–Ω–∏—è
- [ ] –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
- [ ] Mobile responsive
- [ ] –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–∞–∑–Ω—ã—Ö –∫–æ—à–µ–ª—å–∫–æ–≤
- [ ] Transaction history

---

## üõ†Ô∏è –ü–æ–ª–µ–∑–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã

**Development:**
- Hardhat / Foundry - —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞
- Remix - –±—ã—Å—Ç—Ä–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
- Tenderly - debugging
- Etherscan - verify –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤

**Testing:**
- Ganache - –ª–æ–∫–∞–ª—å–Ω—ã–π –±–ª–æ–∫—á–µ–π–Ω
- Hardhat Network - –≤—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è —Å–µ—Ç—å
- Fork Mainnet - —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏

**Monitoring:**
- Etherscan API - –¥–∞–Ω–Ω—ã–µ –±–ª–æ–∫—á–µ–π–Ω–∞
- The Graph - –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—è —Å–æ–±—ã—Ç–∏–π
- Alchemy/Infura Dashboard - –º–µ—Ç—Ä–∏–∫–∏
- Sentry - error tracking

**Security:**
- Slither - —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑
- Mythril - security scanner
- OpenZeppelin Defender - –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è
- Certora - formal verification

---

## üìö –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã

**–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è:**
- https://docs.ethers.org/
- https://web3py.readthedocs.io/
- https://docs.openzeppelin.com/

**Tutorials:**
- https://ethereum.org/en/developers/
- https://hardhat.org/tutorial
- https://docs.alchemy.com/

**Communities:**
- Ethereum Stack Exchange
- Reddit r/ethdev
- Discord —Å–µ—Ä–≤–µ—Ä—ã –ø—Ä–æ–µ–∫—Ç–æ–≤

---

## üéØ Roadmap –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∏–∑—É—á–µ–Ω–∏—è

1. **–£–≥–ª—É–±–ª–µ–Ω–Ω–æ:**
   - Layer 2 (Optimism, Arbitrum, zkSync)
   - MEV –∏ Flashbots
   - Account Abstraction (ERC-4337)
   - Cross-chain bridges

2. **–°–ø–µ—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è:**
   - DeFi protocols (Uniswap, Aave, Compound)
   - NFT platforms
   - DAO governance
   - Gaming (Unity + Web3)

3. **–ò–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞:**
   - Running Ethereum node
   - Indexing —Å The Graph
   - IPFS integration
   - Oracle development

–¢–µ–ø–µ—Ä—å —É –≤–∞—Å –µ—Å—Ç—å –≤—Å–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã—Ö Web3 –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π! üöÄ
````